#pragma kernel calculate_initial_spectrum
#pragma kernel calculate_conjugated_spectrum

#define OCEAN_WAVES_BASICS_PI 3.1415926

RWTexture2D<float4> h0;
RWTexture2D<float4> h0_conj;
// xz - вектор волны
RWTexture2D<float4> wave_data;

cbuffer params
{
    int mesh_size;
    int wp_mesh_size;
    float amplitude;
    float2 wind_direction;
    float chop;
    float wind_speed;
    float gravity;
    float k_w_pow;
}

const float min_height_threshold = 1.0e-4;
const float sq_min_height_threshold = 1.0e-8;
const float min_length_threshold = 1.0e-6;

// Функции хэширования
//Источник: https://www.shadertoy.com/view/Xt3cDn
//Лицензия MIT
//Данная лицензия разрешает лицам, получившим копию данного программного обеспечения и сопутствующей документации (далее — Программное обеспечение), безвозмездно использовать Программное обеспечение без ограничений, включая неограниченное право на использование, копирование, изменение, слияние, публикацию, распространение, сублицензирование и/или продажу копий Программного обеспечения, а также лицам, которым предоставляется данное Программное обеспечение, при соблюдении следующих условий:
// Указанное выше уведомление об авторском праве и данные условия должны быть включены во все копии или значимые части данного Программного обеспечения.
// ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНО ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО ИСКАМ, ЗА УЩЕРБ ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ ИЛИ ИНОЙ СИТУАЦИИ, ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ ДЕЙСТВИЙ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.
uint base_hash(uint3 p)
{
    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));
    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));
    return h32 ^ (h32 >> 16);
}

float2 hash23(float3 x)
{
    uint n = base_hash(x);
    uint2 rz = uint2(n, n * 48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html
    return float2(rz.xy & (uint2) 0x7fffffffU) / float(0x7fffffff);
}

float box_muller_rnd(uint3 id)
{
    float2 random = hash23(id);
    return cos(2 * OCEAN_WAVES_BASICS_PI * random.x) * sqrt(-2 * random.y);
}

float phillips_spectrum(uint3 id)
{
    // Получение вектора волны
    float2 k = float2(
        OCEAN_WAVES_BASICS_PI * (2 * id.x - mesh_size) / wp_mesh_size,
        OCEAN_WAVES_BASICS_PI * (2 * id.y - mesh_size) / wp_mesh_size
    );
    wave_data[uint3(id.xy, 0)] = float4(k.x, 0, k.y, 1);
    float k_length = length(k);
    // Если полученный вектор меньше некоторого малого значения,
    // то спектр равен нулю
    if (k_length < min_length_threshold) return 0.0f;

    // Определение макросов для дальнейших операций
    #define K_LENGTH2 k_length * k_length
    #define K_LENGTH4 k_length * k_length * k_length * k_length

    // Получение значений, необходимых для вычисления спектра Филипса в точке xyz
    float k_dot_w = dot(normalize(k), normalize(wind_direction));
    float wave_length = length(wind_speed);
    float L = wave_length * wave_length / gravity;
    #define L2 L * L

    // Вывод значения спектра Филипса
    return amplitude * exp(-1.0f / (K_LENGTH2 * L2)) / K_LENGTH4 * pow(k_dot_w, k_w_pow) * exp(-K_LENGTH2 * L2);
}

void initial_phillips_spectrum(uint3 id){
    uint3 coords = id;
    // Получение нормально распределенных случайных значений
    float2 noise = float2(box_muller_rnd(coords), box_muller_rnd(uint3(coords.xy, coords.z + hash23(coords).x)));
    // Получение итогового значения для спектра Филипса
    float2 result = noise * sqrt(phillips_spectrum(coords) / 2.0f);
    h0[uint3(id.xy, 0)] = float4(result.x, result.y, 0, 1);
}

void conjugated_phillips_spectrum(uint3 id){
    uint3 coords = uint3(-id.xy, id.z);
    // Получение нормально распределенных случайных значений
    float2 noise = float2(box_muller_rnd(coords), box_muller_rnd(uint3(coords.xy, coords.z + hash23(coords).x)));
    // Получение итогового значения для спектра Филипса
    float2 result = noise * sqrt(phillips_spectrum(coords) / 2.0f);
    h0_conj[uint3(id.xy, 0)] = float4(result.x, result.y, 0, 1);
    h0_conj[uint3(id.xy, 0)].y *= -1.0f;
}

[numthreads(8,8,1)]
void calculate_initial_spectrum(uint3 id : SV_DispatchThreadID) {
    initial_phillips_spectrum(uint3(id.xy, 0));
}

[numthreads(8,8,1)]
void calculate_conjugated_spectrum(uint3 id : SV_DispatchThreadID) {
    conjugated_phillips_spectrum(uint3(id.xy, 0));
}

